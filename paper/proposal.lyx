#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Address
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
title{CPSC 433 - Course Scheduling Problem}
\end_layout

\begin_layout Plain Layout


\backslash
author{
\end_layout

\begin_layout Plain Layout

Konrad Aust 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
and
\end_layout

\begin_layout Plain Layout

Mark Barley
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
and
\end_layout

\begin_layout Plain Layout

Kendra Wannamaker
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
and
\end_layout

\begin_layout Plain Layout

Thomas Bystersky
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
and
\end_layout

\begin_layout Plain Layout

Jordan Wallace
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
and
\end_layout

\begin_layout Plain Layout

Aaron Mouratidis
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
maketitle
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
Abstract
\end_layout

\begin_layout Standard
In this paper, we will present two approaches to solving the scheduling
 problem for the Computer Science Department at the University of Calgary.
 The first is a set-based search model, with a genetic approach.
 The second is an And-Tree based model that subdivides the schedule and
 attempts to combine subproblems to find an overall solution.
 
\end_layout

\begin_layout Section
CPSC Department Specific Instance
\end_layout

\begin_layout Standard
We can transform the input for the CPSC-specific instance of the problem
 into a general instance of the problem like so:
\end_layout

\begin_layout Standard
<TODO>
\end_layout

\begin_layout Section
Set Based Search
\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
This is a genetic algorithms approach that begins with a set of valid, unoptimiz
ed solutions, and then for a number of generations uses mutate and crossover
 operations on some subset of the population to create a gradually improving
 solution.
\end_layout

\begin_layout Standard
The desirability of a given solution is given by the 
\begin_inset Formula $Eval$
\end_inset

 function.
 More desirable solutions are cross-bred and mutated, and their offspring
 are added to the next generation.
 From one generation to the next, the members that survive are randomly
 selected with a bias towards those with a lower 
\begin_inset Formula $Eval$
\end_inset

 value.
 The rest are discarded, and those that survive are crossbred and mutated
 accordingly.
 The members that survive are randomly selected with a bias towards those
 with a lower 
\begin_inset Formula $Eval$
\end_inset

 value.
\end_layout

\begin_layout Standard
Mutations and crossovers are done in such a way that all solutions are kept
 valid.
 There will never be a solution in the population that does not satisfy
 all hard constraints.
 
\end_layout

\begin_layout Standard
The algorithm terminates after a number of generations determined at runtime.
 After simulating the generations, the final solution is the member of the
 population with the lowest 
\begin_inset Formula $Eval$
\end_inset

 value.
\end_layout

\begin_layout Subsection
Search Model
\end_layout

\begin_layout Standard
We have some relations and variables included in our problem definition.
 We will refer to them as follows:
\end_layout

\begin_layout Itemize
\begin_inset Formula $L$
\end_inset

=Set of Labs
\end_layout

\begin_layout Itemize
\begin_inset Formula $C$
\end_inset

=Set of Courses
\end_layout

\begin_layout Itemize
\begin_inset Formula $D$
\end_inset

=Set of slots
\end_layout

\begin_layout Itemize
\begin_inset Formula $N$
\end_inset

=not-compatible relation, 
\begin_inset Formula $N:\,L\cup C\times L\cup C$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $U$
\end_inset

=unwanted relation, 
\begin_inset Formula $U:\,L\cup C\times S$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $PopCap$
\end_inset

=The maximum number of solutions we have at any given time.
\end_layout

\begin_layout Itemize
\begin_inset Formula $GenCount$
\end_inset

=The number of generations (iterations) that we simulate.
\end_layout

\begin_layout Standard
Facts in this system are represented as tuples that map courses and labs
 to time slots.
 
\end_layout

\begin_layout Standard
Solutions 
\begin_inset Formula $I$
\end_inset

 are sets of facts.
 They are essentially assignment relations.
 In our system, all solutions must satisfy the 
\begin_inset Formula $Constr$
\end_inset

 function.
\end_layout

\begin_layout Standard
Search States are sets of solutions, which we refer to as populations.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathbb{A}=(S,T)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
S\subseteq2^{F},\,\forall s\in S,\,|s|\leq PopCap,\ \forall x\in s,\,Constr(x)=true
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
T=\left\{ (s,s')|\exists A,B\in Ext,\,A\subseteq s,\;s'=(s-A)\cup B\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
f\in F\iff f:\,(L\cup C)\times D
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Ext=\left\{ A\rightarrow B|A,B\subseteq F,\,\forall s\in S,\left((s-A)\cup B\right)\in S,\left(Mutate(A,B)\lor Crossover(A,B)\right)\right\} 
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Mutation Function
\end_layout

\begin_layout Standard
The mutation function mutate(A,B) takes as input a singleton set 
\begin_inset Formula $A\subseteq F$
\end_inset

, and transforms it into another singleton set 
\begin_inset Formula $B\subseteq F$
\end_inset

.
 
\end_layout

\begin_layout Standard
We can let 
\begin_inset Formula $f\in A$
\end_inset

 be the only item in the singleton set.
 We know that 
\begin_inset Formula $f\in F$
\end_inset

, since 
\begin_inset Formula $A\subseteq F$
\end_inset

.
\end_layout

\begin_layout Standard
Our mutation function then does two operations.
\end_layout

\begin_layout Subsubsection*
Reassignment of a Course or Lab
\end_layout

\begin_layout Standard
If there exists a slot 
\begin_inset Formula $s\in D$
\end_inset

 such that 
\begin_inset Formula $\forall x\in(L\cup C)$
\end_inset

, 
\begin_inset Formula $(x,s)\notin A$
\end_inset

, (That is to say, that slot has not been assigned any courses or labs),
 then let we transform 
\begin_inset Formula $f$
\end_inset

 as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
f'=f-\{(a,s)\}+\{(a,s')\}
\]

\end_inset


\end_layout

\begin_layout Standard
Where 
\begin_inset Formula $(a,s)\in f$
\end_inset

, 
\begin_inset Formula $a\in(C\cup L)$
\end_inset

, 
\begin_inset Formula $s'\in D$
\end_inset

, and the following holds:
\end_layout

\begin_layout Itemize
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

 are randomly selected with uniform distribution over all 
\begin_inset Formula $(C\cup L)$
\end_inset

 and all 
\begin_inset Formula $D$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Constr(f^{\prime})=true$
\end_inset


\end_layout

\begin_layout Standard
If no slots and assignable courses or labs exist that satisfy this criteria,
 then let 
\begin_inset Formula $f'=f$
\end_inset

 and move on to the next step:
\end_layout

\begin_layout Subsubsection*
Swapping of Two Assignments
\end_layout

\begin_layout Standard
We transform 
\begin_inset Formula $f^{\prime}$
\end_inset

 to produce another fact, 
\begin_inset Formula $f^{\prime\prime}$
\end_inset

 as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
f^{\prime\prime}=f^{\prime}-\{(a,s_{a}),(b,s_{b})\}+\{(a,s_{b}),(b,s_{a})\}
\]

\end_inset


\end_layout

\begin_layout Standard
Where 
\begin_inset Formula $\left\{ (a,s_{a}),(b,s_{b})\right\} \in f^{\prime}$
\end_inset

, 
\begin_inset Formula $a,b\in(C\cup L)$
\end_inset

, 
\begin_inset Formula $s_{a},s_{b}\in D$
\end_inset

, and the following holds:
\end_layout

\begin_layout Itemize
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

 are randomly selected with uniform distribution over all 
\begin_inset Formula $(C\cup L)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $Constr(f^{\prime\prime})=true$
\end_inset


\end_layout

\begin_layout Standard
If no slots and assignable courses or labs exist that satisfy this criteria,
 then let 
\begin_inset Formula $f^{\prime\prime}=f^{\prime}$
\end_inset

.
 Now we can define 
\begin_inset Formula $B$
\end_inset

 as the set containing our transformed fact as well as our original fact.
 
\begin_inset Formula 
\[
B=\{f,f^{\prime\prime}\}
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Crossover Function
\end_layout

\begin_layout Standard
The crossover function crossover(A,B) takes as input a two-item set 
\begin_inset Formula $A\subseteq F$
\end_inset

, 
\begin_inset Formula $|A|=2$
\end_inset

 and transforms it into another set 
\begin_inset Formula $B\subseteq F$
\end_inset

.
 
\end_layout

\begin_layout Standard
We can let 
\begin_inset Formula $M,F\in A$
\end_inset

 be the mother and father facts for this crossover.
 It does not matter which is which, they can be selected arbitrarily.
 
\end_layout

\begin_layout Standard
We do our crossover operation as an or-tree-based search.
\end_layout

\begin_layout Subsubsection*
Crossover Search Model
\end_layout

\begin_layout Standard
The search model is no more specific than that of a regular or-tree-based
 search, except we define 
\begin_inset Formula $Prob$
\end_inset

 with the following statement:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
pr\in Prob\iff pr=(L,C,D,N,U,Z,M,F,par)
\]

\end_inset

Where 
\end_layout

\begin_layout Itemize
\begin_inset Formula $L$
\end_inset

=Set of Labs
\end_layout

\begin_layout Itemize
\begin_inset Formula $C$
\end_inset

=Set of Courses
\end_layout

\begin_layout Itemize
\begin_inset Formula $D$
\end_inset

=Set of slots
\end_layout

\begin_layout Itemize
\begin_inset Formula $N$
\end_inset

=not-compatible relation, 
\begin_inset Formula $N:\,L\cup C\times L\cup C$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $U$
\end_inset

=Unwanted relation, 
\begin_inset Formula $U:\,L\cup C\times S$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $Z$
\end_inset

=Assign relation, 
\begin_inset Formula $Z:L\cup C\times S$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $M$
\end_inset

=The mother for the crossover.
 
\begin_inset Formula $M\in A$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $F$
\end_inset

=The father for the crossover.
 
\begin_inset Formula $F\in A$
\end_inset

, 
\begin_inset Formula $F\neq M$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $par$
\end_inset

=The current parent we are taking genetic material from.
 This switches at each level of our search tree.
 
\begin_inset Formula $par\in\{M,F\}$
\end_inset


\end_layout

\begin_layout Standard
Then we define the Altern relation as follows:
\end_layout

\begin_layout Subsubsection*
Altern(pr):
\end_layout

\begin_layout Standard
For each 
\begin_inset Formula $(a_{i},s_{i})\in(L\cup C)\times S$
\end_inset

 where: 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\forall m$
\end_inset

 such that 
\begin_inset Formula $(m,s)\in Z,\;\neg N(a_{i},m)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\neg U(a_{i},s_{i})$
\end_inset


\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $a_{i}\in L$
\end_inset

 and 
\begin_inset Formula $a_{i}$
\end_inset

 has some corresponding course 
\begin_inset Formula $c\in C$
\end_inset

,
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $(c,s_{i})\notin Z$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Else if 
\begin_inset Formula $a_{i}\in C$
\end_inset

 and 
\begin_inset Formula $a_{i}$
\end_inset

 has some correspoinding labs 
\begin_inset Formula $\left\{ l_{1},...,l_{n}\right\} $
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\forall l_{j}$
\end_inset

 where 
\begin_inset Formula $1\leq j\leq n$
\end_inset

, 
\begin_inset Formula $(l_{j},s)\notin Z$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Create a new problem definition 
\begin_inset Formula $pr_{i}=(L,C,S,N,U,Z',M,F,par')$
\end_inset

 where 
\begin_inset Formula $Z'=Z+(a_{i},s_{i})$
\end_inset

 and 
\begin_inset Formula 
\[
par'=\begin{cases}
M & par=F\\
F & par=M
\end{cases}
\]

\end_inset


\begin_inset Newline newline
\end_inset

(This causes the currently active parent to be swapped at every level of
 the tree.)
\end_layout

\begin_layout Standard
We then say that the following relationship holds: 
\begin_inset Formula 
\[
Altern(pr,pr_{1},pr_{2},...,pr_{i})
\]

\end_inset


\end_layout

\begin_layout Subsubsection*
Crossover Search Process
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathbb{{P}}=(\mathbb{{A}},Env,\mbox{\mathbb{K}})
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathbb{{K}}(s,e)=s^{\prime}
\]

\end_inset


\end_layout

\begin_layout Standard
Where 
\begin_inset Formula $s^{\prime}$
\end_inset

 is a uniformly randomly selected state from 
\begin_inset Formula $Altern(s)$
\end_inset

 that satisfies:
\begin_inset Formula 
\[
\forall x\in S,\;f_{leaf}(x)\geq f_{leaf}(s^{\prime})
\]

\end_inset


\end_layout

\begin_layout Standard
We define 
\begin_inset Formula $f_{leaf}(m)$
\end_inset

 as follows:
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $m$
\end_inset

 be a search state.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $Z_{m}$
\end_inset

be the assignment relation of 
\begin_inset Formula $m$
\end_inset

.
 (The sixth item of the problem instance tuple in state 
\begin_inset Formula $m$
\end_inset

).
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $parent_{m}$
\end_inset

 be the current parent of 
\begin_inset Formula $m$
\end_inset

.
 (The 
\begin_inset Formula $par$
\end_inset

 value, or the 9th value of the instance tuple in state 
\begin_inset Formula $m$
\end_inset

).
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $altparent_{m}$
\end_inset

 be the other parent of 
\begin_inset Formula $m$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
f_{leaf}(m)=\begin{cases}
1 & \exists t\in Z_{m},t\in parent_{m}\\
2 & \exists t\in Z_{m},t\in altparent_{m}\\
3 & otherwise
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
Or, if our transition adds an item from the active parent, it is of the
 highest priority.
 If it is from the inactive parent, it is of lower priority.
 If it is from neither parent, it is of the lowest priority.
 When we select a transition in 
\begin_inset Formula $k$
\end_inset

, we must take one of the highest priority transitions, but it should be
 selected uniformly randomly from all equal priority transitions.
 This is to reflect the randomness necessary in crossover.
 
\end_layout

\begin_layout Standard
A function 
\begin_inset Formula $f_{trans}$
\end_inset

 is not necessary, because we only have one type of operation in 
\begin_inset Formula $Altern$
\end_inset

.
\end_layout

\begin_layout Standard
Using this model, we alternate between taking scheduled items from each
 parent, until no more items fit.
 Then we fill up the schedule using random valid transitions.
 This is not a true crossover function, as some parts are still left to
 chance, but I feel it is a close enough approximation given the complexity
 of this system.
\end_layout

\begin_layout Subsubsection*
Crossover Search Instance
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Ins=(s_{0},\mathbb{G})
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
s_{0}=(pr_{0},?)
\]

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula 
\[
pr_{0}=(L,C,S,N,U,Z,M,F,M)
\]

\end_inset


\end_layout

\begin_layout Standard
with 
\begin_inset Formula $Z$
\end_inset

 intialized to 
\begin_inset Formula $partassign$
\end_inset

, and 
\begin_inset Formula $L,C,S,N,U$
\end_inset

 initialized to their values in our overall search problem.
 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $F$
\end_inset

 are both elements of 
\begin_inset Formula $A$
\end_inset

, such that 
\begin_inset Formula $M\neq F$
\end_inset

.
 They can be assigned arbitrarily.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $\mathbb{G}(s)$
\end_inset

 is no more specific than the basic definition of 
\begin_inset Formula $\mathbb{G}(s)$
\end_inset

 for an or-tree based search.
 We know we have a sol-value of yes when for all 
\begin_inset Formula $x\in(L\cup C)$
\end_inset

, 
\begin_inset Formula $\exists(x,y)\in Z$
\end_inset

 for some 
\begin_inset Formula $y\in D$
\end_inset

.
\end_layout

\begin_layout Standard
Once a solution is found, we can define the output of the relation, 
\begin_inset Formula $B,$
\end_inset

 as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
B=\{M,F,Z\}
\]

\end_inset


\end_layout

\begin_layout Subsection
Seach Control
\end_layout

\begin_layout Standard
TODO: Properly select solutions to mutate and discard.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathbb{P}=(\mathbb{A},Env,\mathbb{K})
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathbb{K}(s,e)=(s-A)\cup B,\:(A\rightarrow B)\in Ext,\:A\subseteq s
\]

\end_inset

where 
\begin_inset Formula 
\[
\forall\left(A^{\prime}\rightarrow B^{\prime}\right)\in Ext,\:A^{\prime}\subseteq s,\,f_{wert}(A,B,e)\leq f_{wert}(A^{\prime},B^{\prime},e)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
A\rightarrow B=f_{select}\left(\left\{ A^{\prime}\rightarrow B^{\prime}|f_{wert}(A^{\prime},B^{\prime},e)\leq f_{wert}(A^{\prime\prime},B^{\prime\prime},e),\;\forall A^{\prime\prime}\rightarrow B^{\prime\prime}\in Ext,\;A^{\prime\prime}\subseteq s\right\} ,e\right)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
f_{wert}(A,B,e)=Eval(B)-Eval(A)+EvalMax
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $f_{select}(A,e)$
\end_inset

 randomly returns some 
\begin_inset Formula $a\in A$
\end_inset

, as a tie breaker.
\end_layout

\begin_layout Standard
\begin_inset Formula $EvalMax$
\end_inset

 is the maximal value that can be returned by Eval.
 We add this to ensure that our values for 
\begin_inset Formula $f_{wert}$
\end_inset

do not go into the negatives.
 This is to ensure that 
\begin_inset Formula $f_{wert}\in\mathbb{{N}}$
\end_inset

.
\end_layout

\begin_layout Subsection
Search Instance
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Ins=(S_{0},\mathbb{G})
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
S_{0}=\left\{ s_{1},s_{2},...-s_{n}\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
Where for 
\begin_inset Formula $1\leq i\leq n$
\end_inset

, 
\begin_inset Formula $S_{o_{i}}=RandomSol()$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $RandomSol()$
\end_inset

 is a function defined below.
\end_layout

\begin_layout Standard
We define 
\begin_inset Formula $G$
\end_inset

 to be true if and only if we are on our last generation, i.e.
 we are on generation number 
\begin_inset Formula $GenCount$
\end_inset

.
 This is the number of generations for which we run our algorithm.
 A higher value should lead to more accurate results, but it will take longer.
 
\end_layout

\begin_layout Standard
The final result returned should be the element of 
\begin_inset Formula $S$
\end_inset

 with the lowest 
\begin_inset Formula $Eval$
\end_inset

 value after the final generation.
\end_layout

\begin_layout Subsubsection
RandomSol Function
\end_layout

\begin_layout Standard
This function generates a pseudorandom solution to the scheduling problem.
 We generate it by traversing an or-tree in random order and returning the
 first solution we find that satisfies all hard constraints.
 
\end_layout

\begin_layout Standard
We use this function to fill our initial population with random members.
\end_layout

\begin_layout Standard
The or-tree-based search is described below.
\end_layout

\begin_layout Subsubsection*
Search Model
\end_layout

\begin_layout Standard
The search model is no more specific than that of a regular or-tree-based
 search, except that we define 
\begin_inset Formula $Prob$
\end_inset

 with the following statement:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
pr\in Prob\iff pr=(L,C,D,N,U,Z)
\]

\end_inset

Where 
\end_layout

\begin_layout Itemize
\begin_inset Formula $L$
\end_inset

=Set of Labs
\end_layout

\begin_layout Itemize
\begin_inset Formula $C$
\end_inset

=Set of Courses
\end_layout

\begin_layout Itemize
\begin_inset Formula $D$
\end_inset

=Set of slots
\end_layout

\begin_layout Itemize
\begin_inset Formula $N$
\end_inset

=not-compatible relation, 
\begin_inset Formula $N:\,L\cup C\times L\cup C$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $U$
\end_inset

=Unwanted relation, 
\begin_inset Formula $U:\,L\cup C\times S$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $Z$
\end_inset

=Assign relation, 
\begin_inset Formula $Z:L\cup C\times S$
\end_inset


\end_layout

\begin_layout Subsubsection*
Altern(pr):
\end_layout

\begin_layout Standard
For each 
\begin_inset Formula $(a_{i},s_{i})\in(L\cup C)\times S$
\end_inset

 where: 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\forall m$
\end_inset

 such that 
\begin_inset Formula $Z(m)=s_{i},\;\neg N(a_{i},m)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\neg U(a_{i},s_{i})$
\end_inset


\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $a_{i}\in L$
\end_inset

 and 
\begin_inset Formula $a_{i}$
\end_inset

 has some corresponding course 
\begin_inset Formula $c\in C$
\end_inset

,
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $(c,s)\notin Z(c)$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
If 
\begin_inset Formula $a\in C$
\end_inset

 and 
\begin_inset Formula $a$
\end_inset

 has some correspoinding labs 
\begin_inset Formula $\left\{ l_{1},...,l_{n}\right\} $
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\forall l_{j}$
\end_inset

 where 
\begin_inset Formula $1\leq j\leq n$
\end_inset

, 
\begin_inset Formula $(l_{j},s)\notin Z$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Create a new problem definition 
\begin_inset Formula $pr_{i}=(L,C,S,N,U,Z')$
\end_inset

 where 
\begin_inset Formula $Z'=Z+(a,s)$
\end_inset

.
\end_layout

\begin_layout Standard
We then say that the following relationship holds: 
\begin_inset Formula 
\[
Altern(pr,pr_{1},pr_{2},...,pr_{i})
\]

\end_inset


\end_layout

\begin_layout Subsubsection*
Search Process
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathbb{P}=(\mathbb{A},Env,\mathbb{K})
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathbb{K}(s,e)=s^{\prime}
\]

\end_inset


\end_layout

\begin_layout Standard
Where 
\begin_inset Formula $s^{\prime}$
\end_inset

 is a uniformly randomly selected state from 
\begin_inset Formula $Altern(s)$
\end_inset

 that satisfies: 
\begin_inset Formula 
\[
\forall x\in S,\;f_{leaf}(x)\geq f_{leaf}(s^{\prime})
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $f_{leaf}(m)$
\end_inset

 is defined as follows:
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $m$
\end_inset

 be a search state.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $depth_{m}$
\end_inset

 be the depth of the node 
\begin_inset Formula $m$
\end_inset

 in the search tree.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $maxdepth=|C_{m}\cup L_{m}|$
\end_inset

, where 
\begin_inset Formula $C_{m}$
\end_inset

 and 
\begin_inset Formula $L_{m}$
\end_inset

 are the sets of courses and labs for the search state, respectively.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
f_{leaf}=maxdepth-depth
\]

\end_inset


\end_layout

\begin_layout Standard
That is to say, our search process will randomly select a leaf to expand
 from the leaves that are the deepest in the tree.
 This is because those leaves are closest to a solution, so expanding them
 first will allow us to finish faster.
\end_layout

\begin_layout Standard
A function 
\begin_inset Formula $f_{trans}$
\end_inset

 is not necessary, because we only have one type of operation in 
\begin_inset Formula $Altern$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Search Instance
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Ins=(s_{0},\mathbb{G})
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
s_{0}=(pr_{0},?)
\]

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula 
\[
pr_{0}=(L,C,S,N,U,Z)
\]

\end_inset


\end_layout

\begin_layout Standard
with 
\begin_inset Formula $Z$
\end_inset

 intialized to 
\begin_inset Formula $partassign$
\end_inset

, and 
\begin_inset Formula $L,C,S,N,U$
\end_inset

 initialized to their values in our overall search problem.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $\mathbb{G}(s)$
\end_inset

 is no more specific than the basic definition of 
\begin_inset Formula $\mathbb{G}(s)$
\end_inset

 for an or-tree based search.
 We know we have a sol-value of yes when for all 
\begin_inset Formula $x\in(L\cup C)$
\end_inset

, 
\begin_inset Formula $Z(x)$
\end_inset

 is defined.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Since RandomSol() is an or-tree-based search, if we are entirely unable
 to find a solution, we know that our problem instance has no possible solution
 before we even start the main algorithm.
\end_layout

\begin_layout Subsection
Example
\end_layout

\begin_layout Standard
TODO: Example.
\end_layout

\begin_layout Section
Tree Based Search
\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Subsection
Search Model
\end_layout

\begin_layout Subsection
Seach Control
\end_layout

\begin_layout Subsection
Search Instance
\end_layout

\begin_layout Subsection
Example
\end_layout

\begin_layout Section
Conclusion
\end_layout

\end_body
\end_document
